#!/usr/bin/env python
# -*- coding: utf-8 -*-

""" cve-check.py: A utility script to fetch CVE data from the AlienVault OTX API."""

# Ownership, licensing and usage documentation
# can be found at the bottom of this script.

import os
import re
from argparse import ArgumentParser
import sys
from rich import print as rprint, pretty
from rich.progress import Progress
import requests
from dotenv import dotenv_values
import pandas

pretty.install()

# ----------------------------------------------------- #

def register_arguments():
    ''' Registers the arguments for the script.'''
    arguments_parser = ArgumentParser(
        description='Utility script to fetch CVE data from the AlienVault OTX API.')

    arguments_parser.add_argument(
        "-i", "--input", help='CVEs to check for (comma separated for multiple CVEs).', dest="cves")
    arguments_parser.add_argument(
        "-o", "--output", help='Output results to CSV file.', dest="csv",
        action='store_true')
    arguments_parser.add_argument(
        "-r", "--raw", help='Display the raw output from the API.', dest="raw", action='store_true')
    arguments_parser.add_argument(
        "-q", "--quiet", help="Does not print to console.", dest="quiet",
        action='store_true')

    return arguments_parser.parse_args()

def get_script_path():
    '''Obtains the directory path of where this script originates. '''
    return os.path.dirname(os.path.realpath(__file__))

def read_env():
    '''Reads the .env file to extract OTX API key.'''
    configuration = dotenv_values(os.path.join(get_script_path(),".env"))

    print(configuration)
    print(configuration['OTX_API_KEY'])

    if configuration["OTX_API_KEY"] not in [None, '', '<your_api_key_goes_here>']:
        return configuration
    else:
        return None

def check_api_for_cve_data(cve, api_key):
    '''Sends an API request to OTX with a CVE to check for data.'''

    with Progress(transient=True) as api_check_progress:
        api_task = api_check_progress.add_task("API Check:", total=10)

        endpoint = f"https://otx.alienvault.com/api/v1/indicators/cve/{cve}/general"
        headers = {'X-OTX-API-KEY': f'{api_key}'}
        api_check_progress.update(api_task, advance=2)

        res = requests.get(endpoint, headers=headers)
        api_check_progress.update(api_task, advance=4)

        if res.status_code == 200:
            api_check_progress.update(api_task, advance=2)

            return res.json()
        else:
            api_check_progress.update(api_task, advance=2)

            return False

def parse_api_response(cve_data, arg):
    '''Parses the response data from the API.'''

    products = []

    output = []

    divider = "\n----"

    f_cve_header = f"[bold italic]Information for {arg}[/bold italic]"

    f_cwe = f"[bold]CWE:[/bold] {cve_data['cwe']}\n"
    f_description = f"{cve_data['description']}\n"

    output.append(f_cwe)
    output.append(f_description)

    f_cvss_header = "[bold italic]CVSS Score[/bold italic]\n"

    f_cvss_base_score = f"[bold]Base Score:[/bold] {cve_data['cvssv3']['cvssV3']['baseScore']}"
    f_cvss_base_severity = f"[bold]Base Severity:[/bold] {cve_data['cvssv3']['cvssV3']['baseSeverity']}"
    f_cvss_exploitability_score = f"[bold]Exploitability Score:[/bold] {cve_data['cvssv3']['exploitabilityScore']}"
    f_cvss_impact_score = f"[bold]Impact Score:[/bold] {cve_data['cvssv3']['impactScore']}"
    f_cia_triad_score_header = f"[bold]CIA Triad Impact[/bold]\n"
    f_cia_confidentiality_score = f"[bold]Confidentiality:[/bold] {cve_data['cvssv3']['cvssV3']['confidentialityImpact']}"
    f_cia_availability_score = f"[bold]Availability:[/bold] {cve_data['cvssv3']['cvssV3']['availabilityImpact']}"
    f_cia_integrity_score = f"[bold]Integrity:[/bold] {cve_data['cvssv3']['cvssV3']['integrityImpact']}"
    
    output.append(f_cve_header)

    output.append(divider)

    output.append(f_cvss_header)
    output.append(f_cvss_base_score)
    output.append(f_cvss_exploitability_score)
    output.append(f_cvss_impact_score)
    output.append(f_cvss_base_severity)

    output.append(divider)
    output.append(f_cia_triad_score_header)
    output.append(f_cia_confidentiality_score)
    output.append(f_cia_availability_score)
    output.append(f_cia_integrity_score)

    output.append(divider)

    f_products_header = f"[bold italic]Affected Products[/bold italic]"

    output.append(f_products_header)

    if cve_data['products']:
        for product in cve_data['products']:
            if product not in products:
                products.append(product)
                f_product_name = f"Product: {product}"
                output.append(f_product_name)

    output.append(divider)

    f_pulse_additional_details_header = "[bold italic]Additional Details[/bold italic]"

    output.append(f_pulse_additional_details_header)

    f_seen_in_wild = f"Seen in the wild: {cve_data['seen_wild']}"

    output.append(f_seen_in_wild)

    output.append(divider)

    if cve_data['references']:
        f_pulse_references_header = "[bold]References[/bold]"

        output.append(f_pulse_references_header)

        for reference in cve_data['references']:
            f_reference_source = f"Source: {reference['external_source']}"
            f_reference_url = f"[link={reference['href']}]{reference['href']}[/link]"
            f_reference_tags = f"Tags: {reference['tags']}"

            output.append(f_reference_source)
            output.append(f_reference_url)
            output.append(f_reference_tags)

    return output


def fetch_cve_data(arg, api_key):
    '''Evaluates the provided arguments and starts the relevant data fetching.'''
    if arg:
        data = check_api_for_cve_data(arg, api_key)
    else:
        data = False

    rprint("")

    if data is False:
        output = ""
        response = (
            '[bold black on red blink]:warning: Failed to get valid response! \
                [/bold black on red blink]')

    else:
        if args.raw:
            output = data
        else:
            output = parse_api_response(data, arg)
        response = (f'[bold black on green blink]Successfully retrieved data on {arg} \
            [/bold black on green blink]')

    if args.csv:
        export_results(arg, data)

    if args.quiet is False:
        rprint(response)
        if args.raw:
            rprint(output)
        else:
            for line in output:
                rprint(line)

    return output

def export_results(arg, data):
    '''Exports the results of the data to a CSV file.'''

    if args.csv:
        filename = os.path.join(get_script_path(), f'{arg}.csv')
        parsed = pandas.DataFrame([data])
        parsed.to_csv(filename, encoding='utf-8', index=False)

# ----------------------------------------------------- #


args = register_arguments()


def main():
    '''The main function of the script.'''

    env = read_env()

    if env is None:
        rprint(
            '[bold black on red blink]:warning: No or invalid API Key provided! \
                Exiting... [/bold black on red blink]')
        sys.exit()

    if args.cves is not None:
        if ',' in str(args.cves):
            cves = args.cves.strip('"').split(',')
            print(cves)
            for cve in cves:
                rprint(f'Fetching CVE data for {cve}')
                check_data = fetch_cve_data(cve, env['OTX_API_KEY'])
        else:
            rprint(f'Fetching CVE data for {args.cves}')
            check_data = fetch_cve_data(args.cves, env['OTX_API_KEY'])

    f_completed_fetch = ("[bold black on green blink]Data fetching complete. \
        [/bold black on green blink]")

    if args.quiet is False:
        rprint(f_completed_fetch)
    else:
        rprint(check_data)
    sys.exit()


if __name__ == "__main__":
    main()

# ------------------------------------------------- #

"""
@Author = "Shrike InfoSec"
@Licence = "MIT"
@Version = "1.0.0"
@Email = "shrike@shrikeinfosec.org"
@Status = "In Development"
"""

"""
    An API key *MUST* be provided - you can register for one at https://otx.alienvault.com/api
    and signing-up for an account.

Examples:

    Look up a single CVE:

        $ python cve-check.py -i CVE-2023-0001

    Look up a single CVE without printing to the console:

        $ python cve-check.py -i CVE-2023-0001 -q

    Lookup multiple CVEs:

        $ python cve-check.py -i "CVE-2023-0001,CVE-2023-0002" -q

    Lookup multiple CVEs and export the results to a .csv file:
    * In future, this will support an optional -f flag for a filename to be specified.

        $ python cve-check.py -i "CVE-2023-0001,CVE-2023-0002" -m

Todo:
    * Implement the -f argument to specify a filename for an exported csv file.

"""
